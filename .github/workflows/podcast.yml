name: Weekly AI Executive Brief

on:
  schedule:
    - cron: '0 15 * * 1'
  workflow_dispatch:
    inputs:
      reason:
        description: 'Why are you running this manually?'
        required: false
        default: 'manual-run'

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install deps
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Generate MP3 + transcript JSON/TXT
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ELEVENLABS_API_KEY: ${{ secrets.ELEVENLABS_API_KEY }}
          ELEVENLABS_VOICE_ID: ${{ secrets.ELEVENLABS_VOICE_ID }}
        shell: bash
        run: |
          set -euo pipefail

          echo "=== Running generator ==="
          python scripts/generate_brief.py

          echo ""
          echo "=== Audio folder listing (newest first) ==="
          ls -lahtr audio | tail -n +1

          echo ""
          echo "=== Find newest MP3 and validate ==="
          LATEST_MP3="$(ls -t audio/ai_news_*.mp3 2>/dev/null | head -1 || true)"
          if [ -z "$LATEST_MP3" ]; then
            echo "ERROR: No MP3 was generated in /audio"
            exit 1
          fi

          BYTES="$(stat -c%s "$LATEST_MP3" 2>/dev/null || stat -f%z "$LATEST_MP3")"
          echo "Newest MP3: $LATEST_MP3 ($BYTES bytes)"

          if [ "$BYTES" -lt 50000 ]; then
            echo "ERROR: MP3 is suspiciously small (<50KB). Likely generation failure."
            exit 1
          fi

          echo "OK: MP3 exists and size looks reasonable."

      - name: DEBUG - Show JSON content
        shell: bash
        run: |
          set -euo pipefail
          echo "=== Latest JSON file ==="
          ls -lt audio/ai_news_*.json | head -1
          echo ""
          echo "=== First 80 lines of JSON content ==="
          cat $(ls -t audio/ai_news_*.json | head -1) | head -80
          echo ""
          echo "=== Structure check ==="
          python3 -c "
          import json
          from pathlib import Path
          jfile = sorted(Path('audio').glob('ai_news_*.json'), key=lambda p: p.stat().st_mtime)[-1]
          data = json.loads(jfile.read_text())
          print(f'Keys in JSON: {list(data.keys())}')
          print(f'Spoken text length: {len(data.get(\"spoken\", \"\"))}')
          print(f'Number of footnotes: {len(data.get(\"footnotes\", []))}')
          "

      - name: Compose email HTML + DOCX + subject
        id: compose
        shell: bash
        run: |
          set -euo pipefail
          python scripts/compose_transcript.py | tee compose.log
          HTML_BODY=$(grep -E '^HTML_BODY=' compose.log | cut -d= -f2-)
          DOCX_PATH=$(grep -E '^DOCX_PATH=' compose.log | cut -d= -f2-)
          SUBJECT_LINE=$(grep -E '^SUBJECT_LINE=' compose.log | cut -d= -f2-)
          echo "html_body=$HTML_BODY" >> $GITHUB_OUTPUT
          echo "docx_path=$DOCX_PATH" >> $GITHUB_OUTPUT
          echo "subject_line=$SUBJECT_LINE" >> $GITHUB_OUTPUT
          echo "Prepared -> $HTML_BODY ; $DOCX_PATH ; $SUBJECT_LINE"

      - name: Send transcript email
        env:
          SMTP_SERVER:   ${{ secrets.SMTP_SERVER }}
          SMTP_PORT:     ${{ secrets.SMTP_PORT }}
          SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          EMAIL_FROM:    ${{ secrets.EMAIL_FROM }}
          EMAIL_TO:      ${{ secrets.EMAIL_TO }}
          SUBJECT:       ${{ steps.compose.outputs.subject_line }}
          ATTACH_PATH:   ${{ steps.compose.outputs.docx_path }}
        shell: bash
        run: |
          set -euo pipefail
          BODY_B64=$(base64 -w 0 "${{ steps.compose.outputs.html_body }}")
          export BODY_B64
          python scripts/send_email.py

      - name: Update feed.xml (point enclosure to latest mp3)
        shell: bash
        run: |
          set -euo pipefail
          python scripts/update_feed.py

      - name: DEBUG - Verify feed.xml was updated (safe)
        shell: bash
        run: |
          set -euo pipefail
          echo "=== First 30 lines of feed.xml ==="
          sed -n '1,30p' feed.xml
          echo ""
          echo "=== Last build date ==="
          grep "lastBuildDate" feed.xml || true
          echo ""
          echo "=== First item (bounded, no broken pipe) ==="
          awk 'BEGIN{p=0} /<item>/{p=1} p{print} /<\/item>/{exit}' feed.xml | sed -n '1,25p'

      - name: Stage all changes explicitly
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add feed.xml
          git add audio/*
          echo "=== Git status after staging ==="
          git status

      - name: Commit audio, feed, and transcript assets
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Update podcast assets (audio/feed/transcript)"
          file_pattern: |
            audio/*
            feed.xml
          branch: ${{ github.ref }}
          skip_dirty_check: true
